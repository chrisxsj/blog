# shell_conditionals_excution

**作者**

Chrisx

**日期**

2022-01-26

**内容**

shell条件执行

----

[toc]

## 条件测试

条件测试语法

| 语法          | 描述                                                                       |
| ------------- | -------------------------------------------------------------------------- |
| test表达式    | 使用test命令进行条件测试，test命令与表达式之间至少一个空格，主要使用方式。 |
| [ 表达式 ]    | 使用[]中括号进行条件测试，中括号边界与表达式之间至少一个空格               |
| \[[ 表达式 ]] | 使用[[]]双中括号进行条件测试，双中括号边界与表达式之间至少一个空格         |
| ((表达式))    | 使用(())双小括号进行条件测试，双小括号边界不需要空格，常用于整数对比       |

符号说明

* (())，用于数值比较，运算
* [[]]，用于条件测试，支持正则
* \$(())与$[]，用于整数运算
* $()，用于命令替换，等于``
* ${}，用于变量运算，变量原型
* ()，在子shell中运行
* {}，在当前shell中运行

:warning: ()只影响子shell，{}是当前shell，中边界要有空格，命令结尾要有分号;

### 文件测试表达式

对文件条件测试是否为真

* -d file，文件存在且为目录则为真
* -f file，文件存在且为普通文件则为真
* -e file，文件存在则为真，不辨别文件或目录
* -s file，文件存在且文件大小不为0则为真
* -r file，文件存在且可读则为真，与执行脚本用户权限无关。
* -w file，文件存在且可写则为真，与执行脚本用户权限无关。
* -x file，文件存在且可执行则为真，与执行脚本用户权限无关。
* -L file，文件存在且为链接文件则为真
* f1 -nt f2，文件1比文件2新则为真，根据文件修改时间计算
* f1 -ot f2，文件1比文件2旧则为真，根据文件修改时间计算

示例：

```sh
[ -d $(pwd) ];echo $?
[ -f $(pwd) ];echo $?
```

### 字符串表达式

对字符串条件测试是否为真

* -z s1，字符串s1长度为0则为真
* -n s1，字符串s1长度大于0则为真
* s1 = s2，字符串s1等于s2则为真，“=”前后应有空格，也可使用“==”
* s1 != s2，字符串s1不等于s2则为真
* s1 < s2，按字典顺序，s1在s2之前，则测试条件为真
* s1 > s2，按字典顺序，s1在s2之后，则测试条件为真

示例：

```sh
[ $user = "root" ];echo $?
[ -n $(pwd) ];echo $?
```

### 整数操作符

对整数条件测试

| 在[]和test中使用 | 在[[]]和(())中使用 | 说明                    |
| ---------------- | ------------------ | ----------------------- |
| -eq              | =或==              | 等于，equal             |
| -nq              | !=                 | 不等于，not equal       |
| -gt              | >                  | 大于，greater than      |
| -ge              | >=                 | 大于等于，greater equal |
| -lt              | <                  | 小于，less than         |
| -le              | <=                 | 小于等于，less equal    |

示例

```sh

```
<!--
# case
# case也是一个流程控制，可以用更精细的方式表达if-elif语句
case expression in
pattern1)
    statements;;
pattern2)
    statements;;
pattern3 | pattern4)
    statements;;
esac

# 跳出循环
break       #跳出循环
continue    #继续循环


command | while read line

do

    …

done

如果你还记得管道的用法，这个结构应该不难理解吧。command命令的输出作为read循环的输入，这种结构常用于处理超过一行的输出，当然awk也很擅长做这种事
-->


